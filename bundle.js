/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var binary_tree_visualizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-tree-visualizer */ \"./node_modules/binary-tree-visualizer/lib/index.js\");\n\nvar form = document.querySelector('form');\nform.addEventListener('submit', function (e) {\n  e.preventDefault(); //get the input data from the text area\n\n  var arrayString = document.getElementById('array').value;\n  var num = arrayString.split(\" \").map(function (x) {\n    return parseInt(x);\n  });\n  var root = new binary_tree_visualizer__WEBPACK_IMPORTED_MODULE_0__.BinarySearchTreeNode(num[0]);\n  num.shift(); //them for the binary tree\n\n  (0,binary_tree_visualizer__WEBPACK_IMPORTED_MODULE_0__.setTheme)({\n    radius: 25,\n    leafNodeSpace: 90,\n    lineHeight: 120,\n    textFont: 'Poppins',\n    strokeColor: '#000000',\n    growthAndShrinkTimes: 1.45,\n    colorArray: [{\n      borderColor: '#000000',\n      bgColor: '#F8EDE5'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#CB6CE6'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#5CE1E6'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#C0EFCC'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#C8B9FF'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#95A984'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#FFADFC'\n    }, {\n      borderColor: '#000000',\n      bgColor: '#66C0C0'\n    }]\n  }); //inserting the elements\n\n  num.forEach(function (element) {\n    root.insert(element);\n  });\n  (0,binary_tree_visualizer__WEBPACK_IMPORTED_MODULE_0__.drawBinaryTree)(root, document.querySelector('canvas'), {\n    type: binary_tree_visualizer__WEBPACK_IMPORTED_MODULE_0__.VisualizationType.PRETTY,\n    maxHeight: 200,\n    maxWidth: 200\n  });\n});\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./src/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/Canvas.js":
/*!******************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/Canvas.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _helpers_ColorGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/ColorGenerator */ \"./node_modules/binary-tree-visualizer/lib/helpers/ColorGenerator.js\");\n/* harmony import */ var _utils_getRGBString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getRGBString */ \"./node_modules/binary-tree-visualizer/lib/utils/getRGBString.js\");\n\n\n/**\n * Defines one canvas\n */\nclass CanvasComponent {\n    /**\n     * For constructing a new canvas component\n     *\n     * @param {HTMLCanvasElement} $el\n     */\n    constructor($el) {\n        /**\n         * The current hovering color\n         */\n        this.currentHoveringColor = '';\n        const $hitEl = document.createElement('canvas');\n        this.$el = $el;\n        this.$hitEl = $hitEl;\n        this.colorGenerator = new _helpers_ColorGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    }\n    /**\n     * Clears the canvas\n     */\n    clearCanvas() {\n        const { height, width } = this.$el;\n        this.getContext().clearRect(0, 0, width, height);\n    }\n    /**\n     * Set the maximum width and height\n     *\n     * @param {number} height\n     * @param {number} width\n     */\n    setMaxWidthAndHeight(height, width) {\n        this.$hitEl.height = this.$el.height = height;\n        this.$hitEl.width = this.$el.width = width;\n    }\n    /**\n     * Get the hit 2d context\n     *\n     * @return {CanvasComponent}\n     */\n    getHitContext() {\n        const ctx = this.$hitEl.getContext('2d');\n        if (!ctx) {\n            throw new Error('Cannot get 2d context');\n        }\n        return ctx;\n    }\n    /**\n     * Get the 2d context\n     *\n     * @return {CanvasRenderingContext2D}\n     */\n    getContext() {\n        const ctx = this.$el.getContext('2d');\n        if (!ctx) {\n            throw new Error('Cannot get 2d context');\n        }\n        return ctx;\n    }\n    /**\n     * Get the next color from the color generator\n     *\n     * @return {string}\n     */\n    getNextColor() {\n        return this.colorGenerator.getNextColor();\n    }\n    /**\n     * On hover get the canvas hit color\n     *\n     * @param {GetColorCallBack} cb\n     */\n    onHover(cb) {\n        // Clear previous listeners\n        if (this.onHoverCB) {\n            this.$el.removeEventListener('mousemove', this.onHoverCB);\n        }\n        // Set the callback\n        this.onHoverCB = (event) => {\n            const { pageX, pageY } = event;\n            const { data: pixel } = this.getHitContext().getImageData(pageX - this.$el.offsetLeft, pageY - this.$el.offsetTop, 1, 1);\n            // Callback should only be called on color change\n            const color = (0,_utils_getRGBString__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pixel[0], pixel[1], pixel[2]);\n            if (this.currentHoveringColor !== color) {\n                this.currentHoveringColor = color;\n                cb(color);\n            }\n        };\n        // Add the event listener\n        this.$el.addEventListener('mousemove', this.onHoverCB);\n    }\n    /**\n     * On click of canvas get the hit color\n     *\n     * @param {GetColorCallBack} cb\n     */\n    onClick(cb) {\n        // Clear previous listeners\n        if (this.onClickCB) {\n            this.$el.removeEventListener('click', this.onClickCB);\n        }\n        // Set the callback\n        this.onClickCB = (event) => {\n            const { pageX, pageY } = event;\n            console.log(pageX, pageY);\n            const { data: pixel } = this.getHitContext().getImageData(pageX - this.$el.offsetLeft, pageY - this.$el.offsetTop, 1, 1);\n            cb((0,_utils_getRGBString__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pixel[0], pixel[1], pixel[2]));\n        };\n        // Add the event listener\n        this.$el.addEventListener('click', this.onClickCB);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasComponent);\n//# sourceMappingURL=Canvas.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/Canvas.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/drawBinaryTree.js":
/*!**************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/drawBinaryTree.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enumns_VisualizationType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enumns/VisualizationType */ \"./node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js\");\n/* harmony import */ var _drawPrettyBinaryTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawPrettyBinaryTree */ \"./node_modules/binary-tree-visualizer/lib/canvas/drawPrettyBinaryTree.js\");\n/* harmony import */ var _drawExpandableBinaryTree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawExpandableBinaryTree */ \"./node_modules/binary-tree-visualizer/lib/canvas/drawExpandableBinaryTree.js\");\n/* harmony import */ var _drawSimpleBinaryTree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawSimpleBinaryTree */ \"./node_modules/binary-tree-visualizer/lib/canvas/drawSimpleBinaryTree.js\");\n/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Canvas */ \"./node_modules/binary-tree-visualizer/lib/canvas/Canvas.js\");\n\n\n\n\n\n// For keeping track of canvas components for canvas elements\nconst canvasMap = new Map();\n/**\n * Draw a binary tree in one of the given types\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {Partial<MainInputOptions>} options\n */\nfunction drawBinaryTree(root, canvasElement, options = {}) {\n    const { type = _enumns_VisualizationType__WEBPACK_IMPORTED_MODULE_0__.VisualizationType.SIMPLE, maxHeight = window.innerHeight, maxWidth = window.innerWidth, } = options;\n    const canvasComponent = canvasMap.get(canvasElement) ||\n        new _Canvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"](canvasElement);\n    canvasMap.set(canvasElement, canvasComponent);\n    switch (type) {\n        case _enumns_VisualizationType__WEBPACK_IMPORTED_MODULE_0__.VisualizationType.PRETTY:\n            (0,_drawPrettyBinaryTree__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(root, canvasComponent, {\n                maxHeight,\n                maxWidth,\n            });\n            break;\n        case _enumns_VisualizationType__WEBPACK_IMPORTED_MODULE_0__.VisualizationType.EXPANDABLE:\n            (0,_drawExpandableBinaryTree__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(root, canvasComponent, {\n                maxHeight,\n                maxWidth,\n            });\n            break;\n        case _enumns_VisualizationType__WEBPACK_IMPORTED_MODULE_0__.VisualizationType.HIGHLIGHT:\n            (0,_drawPrettyBinaryTree__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(root, canvasComponent, {\n                maxHeight,\n                maxWidth,\n                highlightMode: true,\n            });\n            break;\n        default:\n            (0,_drawSimpleBinaryTree__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(root, canvasComponent, {\n                maxHeight,\n                maxWidth,\n            });\n            break;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawBinaryTree);\n//# sourceMappingURL=drawBinaryTree.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/drawBinaryTree.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/drawExpandableBinaryTree.js":
/*!************************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/drawExpandableBinaryTree.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n/* harmony import */ var _utils_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/tree */ \"./node_modules/binary-tree-visualizer/lib/utils/tree.js\");\n/* harmony import */ var _utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/connectPointsWithBezierCurve */ \"./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js\");\n\n\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId;\n/**\n * Array of all children that needs printing\n */\nlet globalPathArray;\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId;\n/**\n * Map storing the colorId to the path array\n */\nlet colorIdToPathMap = new Map();\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction requestAnimationFrame(root, comp, options) {\n    // Clear existing animation frame\n    if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId);\n    }\n    // Request a new one\n    animationFrameId = window.requestAnimationFrame(() => animationFrameCB(root, comp, options));\n}\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\nfunction getNodeHeightFromGlobalPathArray() {\n    return globalPathArray.length + 1;\n}\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\nfunction getNodeWidthFromGlobalPathArray() {\n    let left = 0;\n    let right = 0;\n    let current = 0;\n    for (const childDirection of globalPathArray) {\n        if (childDirection === 'left') {\n            current -= 1;\n        }\n        else {\n            current += 1;\n        }\n        if (current < 0) {\n            left = Math.max(Math.abs(current), left);\n        }\n        else {\n            right = Math.max(current, right);\n        }\n    }\n    return {\n        left, right,\n    };\n}\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(node, comp, pathArray, position) {\n    const { x, y } = position;\n    const doesNodeHaveChildren = Boolean(node.left || node.right);\n    node.nodeCircle.setCoordinates(x, y);\n    // Grow or shrink while hover\n    const colorId = node.nodeCircle.draw(comp);\n    colorIdToPathMap.set(colorId, pathArray);\n    if (colorId === hoveredColorId && doesNodeHaveChildren) {\n        return node.nodeCircle.grow();\n    }\n    else {\n        return node.nodeCircle.restoreCircle();\n    }\n}\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\nfunction drawChildren(node, comp, xPosition, nodeHeight, pathArray) {\n    const currentHeight = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(nodeHeight);\n    const childHeight = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(nodeHeight + 1);\n    let requiredRedraw = false;\n    // Draw the left child\n    if (node.left) {\n        const currentPathArray = node.left.left || node.left.right ?\n            [...pathArray, 'left'] : [...pathArray];\n        const xLeft = xPosition - (0.5 * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace);\n        requiredRedraw = drawSingleNode(node.left, comp, currentPathArray, {\n            x: xLeft,\n            y: childHeight,\n        }) || requiredRedraw;\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(comp, {\n            xStart: xPosition,\n            xEnd: xLeft,\n        }, {\n            yStart: currentHeight + node.nodeCircle.getRadius(),\n            yEnd: childHeight - node.left.nodeCircle.getRadius(),\n        });\n    }\n    // Draw the right child\n    if (node.right) {\n        const currentPathArray = node.right.left || node.right.right ?\n            [...pathArray, 'right'] : [...pathArray];\n        const xRight = xPosition + (0.5 * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace);\n        requiredRedraw = drawSingleNode(node.right, comp, currentPathArray, {\n            x: xRight,\n            y: childHeight,\n        }) || requiredRedraw;\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(comp, {\n            xStart: xPosition,\n            xEnd: xRight,\n        }, {\n            yStart: currentHeight + node.nodeCircle.getRadius(),\n            yEnd: childHeight - node.right.nodeCircle.getRadius(),\n        });\n    }\n    return requiredRedraw;\n}\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\nfunction drawAllNodes(root, comp, xRootPosition) {\n    // Draw root\n    let currentNode = root;\n    let xPosition = xRootPosition;\n    let currentNodeHeight = 0.5;\n    const currentPathArray = [];\n    let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n        x: xPosition,\n        y: (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(currentNodeHeight),\n    });\n    // Draw all the children according to the path\n    for (const currentPath of globalPathArray) {\n        requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw;\n        if (currentPath === 'left') {\n            currentNode = currentNode.left;\n            xPosition = xPosition - (0.5 * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace);\n            currentPathArray.push('left');\n        }\n        else {\n            currentNode = currentNode.right;\n            xPosition = xPosition + (0.5 * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace);\n            currentPathArray.push('right');\n        }\n        currentNodeHeight += 1;\n    }\n    // Draw the children of the last element in the path\n    requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw;\n    // Return if redraw is required\n    return requiredRedraw;\n}\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction animationFrameCB(root, comp, options) {\n    // Height and width calculations\n    const nodeHeight = getNodeHeightFromGlobalPathArray();\n    const { left: leftNodeWidth, right: rightNodeWidth, } = getNodeWidthFromGlobalPathArray();\n    const requiredHeight = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(nodeHeight + 1);\n    const requiredWidth = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasWidthFromMaxNodeSpacing)(leftNodeWidth + rightNodeWidth);\n    const actualHeight = Math.max(requiredHeight, options.maxHeight);\n    const actualWidth = Math.max(requiredWidth, options.maxWidth);\n    const xStart = (actualWidth / 2) - (requiredWidth / 2);\n    // Set the height and width\n    // This also clears the canvas. So no need to clear it manually.\n    comp.setMaxWidthAndHeight(actualHeight, actualWidth);\n    // Initialize color id to path map\n    colorIdToPathMap = new Map();\n    // Draw and check if redraw is required\n    const requiredRedraw = drawAllNodes(root, comp, xStart + (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getXPositionFromGivenHorizontalNodePosition)(leftNodeWidth + 1));\n    if (requiredRedraw) {\n        requestAnimationFrame(root, comp, options);\n    }\n}\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawExpandableBinaryTree(root, canvasComponent, options) {\n    // Initialization\n    globalPathArray = [];\n    /**\n     * Click event handler\n     */\n    canvasComponent.onClick((color) => {\n        globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n        requestAnimationFrame(root, canvasComponent, options);\n    });\n    /**\n     * Hover event handler\n     */\n    canvasComponent.onHover((color) => {\n        hoveredColorId = color;\n        requestAnimationFrame(root, canvasComponent, options);\n    });\n    // Draw frame\n    requestAnimationFrame(root, canvasComponent, options);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawExpandableBinaryTree);\n//# sourceMappingURL=drawExpandableBinaryTree.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/drawExpandableBinaryTree.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/drawPrettyBinaryTree.js":
/*!********************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/drawPrettyBinaryTree.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n/* harmony import */ var _utils_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/tree */ \"./node_modules/binary-tree-visualizer/lib/utils/tree.js\");\n/* harmony import */ var _utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/connectPointsWithBezierCurve */ \"./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js\");\n\n\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId;\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId;\n/**\n * Spacing map for storing space requirements\n */\nlet spacingMap;\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\nfunction requestAnimationFrame(root, canvasComponent, position, highlightMode) {\n    // Clear existing animation frame\n    if (animationFrameId) {\n        cancelAnimationFrame(animationFrameId);\n    }\n    // Request a new one\n    animationFrameId = window.requestAnimationFrame(() => {\n        canvasComponent.clearCanvas();\n        const requiredRedraw = recursivelyDrawNodes(root, canvasComponent, position, highlightMode);\n        if (requiredRedraw) {\n            requestAnimationFrame(root, canvasComponent, position, highlightMode);\n        }\n    });\n}\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(node, comp, position, highlightMode) {\n    const { x, y } = position;\n    node.nodeCircle.setCoordinates(x, y);\n    // Grow or shrink while hover\n    const colorId = node.nodeCircle.draw(comp);\n    if (colorId === hoveredColorId && highlightMode) {\n        return node.nodeCircle.grow();\n    }\n    else {\n        return node.nodeCircle.restoreCircle();\n    }\n}\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\nfunction recursivelyDrawNodes(root, canvasComponent, position, highlightMode) {\n    const { x: xPosition, y: yPosition } = position;\n    // Draw the node\n    let requiredRedraw = drawSingleNode(root, canvasComponent, { x: xPosition, y: yPosition }, highlightMode);\n    root.nodeCircle.setCoordinates(xPosition, yPosition);\n    root.nodeCircle.draw(canvasComponent);\n    // Root spacings\n    const { left, right } = spacingMap.get(root);\n    // Draw the left child\n    if (root.left) {\n        const leftOfLeft = spacingMap.get(root.left).left;\n        const childYPosition = yPosition + _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lineHeight;\n        const leftPosition = {\n            x: xPosition - (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getXPositionFromGivenHorizontalNodePosition)(left - leftOfLeft),\n            y: childYPosition,\n        };\n        requiredRedraw = recursivelyDrawNodes(root.left, canvasComponent, leftPosition, highlightMode) || requiredRedraw;\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(canvasComponent, {\n            xStart: xPosition,\n            xEnd: leftPosition.x,\n        }, {\n            yStart: yPosition + root.nodeCircle.getRadius(),\n            yEnd: childYPosition - root.left.nodeCircle.getRadius(),\n        });\n    }\n    // Draw the right child\n    if (root.right) {\n        const rightOfRight = spacingMap.get(root.right).right;\n        const childYPosition = yPosition + _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lineHeight;\n        const rightPosition = {\n            x: xPosition + (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getXPositionFromGivenHorizontalNodePosition)(right - rightOfRight),\n            y: childYPosition,\n        };\n        requiredRedraw = recursivelyDrawNodes(root.right, canvasComponent, rightPosition, highlightMode) || requiredRedraw;\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(canvasComponent, {\n            xStart: xPosition,\n            xEnd: rightPosition.x,\n        }, {\n            yStart: yPosition + root.nodeCircle.getRadius(),\n            yEnd: childYPosition - root.right.nodeCircle.getRadius(),\n        });\n    }\n    return requiredRedraw;\n}\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\nfunction calculateSpacingMapRecursively(root) {\n    const left = root.left ? calculateSpacingMapRecursively(root.left) + 0.5 : 0;\n    const right = root.right ? calculateSpacingMapRecursively(root.right) + 0.5 : 0;\n    spacingMap.set(root, {\n        left,\n        right,\n    });\n    return left + right;\n}\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawPrettyBinaryTree(root, canvasComponent, options) {\n    spacingMap = new Map();\n    const maxNodeSpacing = calculateSpacingMapRecursively(root);\n    const heightOfTree = root.getHeight();\n    const { maxHeight, maxWidth, highlightMode } = options;\n    // Calculate canvas spacing requirements\n    const { maxCanvasWidthRequired, actualMaxHeight, actualMaxWidth, } = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getRequiredAndActualHeightAndWidth)(maxNodeSpacing, heightOfTree, maxWidth, maxHeight);\n    // Init calculation\n    const left = spacingMap.get(root).left;\n    const midPointInCanvas = actualMaxWidth / 2;\n    const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2);\n    // Initialize the canvas\n    canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n    /**\n     * Hover event handler\n     */\n    canvasComponent.onHover((color) => {\n        hoveredColorId = color;\n        requestAnimationFrame(root, canvasComponent, {\n            x: xStart + (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getXPositionFromGivenHorizontalNodePosition)(left + 1),\n            y: (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(0.5),\n        }, Boolean(highlightMode));\n    });\n    // Recursively draw all nodes\n    requestAnimationFrame(root, canvasComponent, {\n        x: xStart + (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getXPositionFromGivenHorizontalNodePosition)(left + 1),\n        y: (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(0.5),\n    }, Boolean(highlightMode));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawPrettyBinaryTree);\n//# sourceMappingURL=drawPrettyBinaryTree.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/drawPrettyBinaryTree.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/drawSimpleBinaryTree.js":
/*!********************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/drawSimpleBinaryTree.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n/* harmony import */ var _utils_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/tree */ \"./node_modules/binary-tree-visualizer/lib/utils/tree.js\");\n/* harmony import */ var _utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/connectPointsWithBezierCurve */ \"./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js\");\n\n\n\n/**\n * Recursively draw all the nodes\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {number} currentLine\n * @param {HorizontalStartAndEndInput} horizontalConfig\n */\nfunction recursivelyDrawNodes(root, canvasComponent, currentLine, horizontalConfig) {\n    // X Calculation\n    const { xStart, xEnd } = horizontalConfig;\n    const xPosition = (xStart + xEnd) / 2;\n    // Y Calculation\n    const yPosition = currentLine * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lineHeight;\n    // Draw the node\n    root.nodeCircle.setCoordinates(xPosition, yPosition);\n    root.nodeCircle.draw(canvasComponent);\n    // Draw the left child nodes\n    // Radius is added and subtracted from y to move the line outside the circle\n    if (root.left) {\n        recursivelyDrawNodes(root.left, canvasComponent, currentLine + 1, {\n            xStart,\n            xEnd: xPosition,\n        });\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(canvasComponent, {\n            xStart: xPosition,\n            xEnd: (xStart + xPosition) / 2,\n        }, {\n            yStart: yPosition + _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radius,\n            yEnd: (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(currentLine + 1) - _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radius,\n        });\n    }\n    if (root.right) {\n        recursivelyDrawNodes(root.right, canvasComponent, currentLine + 1, {\n            xStart: xPosition,\n            xEnd,\n        });\n        (0,_utils_connectPointsWithBezierCurve__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(canvasComponent, {\n            xStart: xPosition,\n            xEnd: (xPosition + xEnd) / 2,\n        }, {\n            yStart: yPosition + _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radius,\n            yEnd: (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getCanvasHeightFromTreeHeight)(currentLine + 1) - _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radius,\n        });\n    }\n}\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawSimpleBinaryTree(root, canvasComponent, options) {\n    const heightOfTree = root.getHeight();\n    const maxNumberOfLeafNodes = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getMaxLeafNodesFromHeight)(heightOfTree);\n    const { maxHeight, maxWidth } = options;\n    // Max height and width requirements\n    const { maxCanvasWidthRequired, actualMaxHeight, actualMaxWidth, } = (0,_utils_tree__WEBPACK_IMPORTED_MODULE_1__.getRequiredAndActualHeightAndWidth)(maxNumberOfLeafNodes, heightOfTree, maxWidth, maxHeight);\n    // Init calculation\n    const midPointInCanvas = actualMaxWidth / 2;\n    const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2) +\n        _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace;\n    const xEnd = (midPointInCanvas + maxCanvasWidthRequired / 2) -\n        _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace;\n    // Initialize the canvas\n    canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n    // Recursively draw the tree\n    recursivelyDrawNodes(root, canvasComponent, 0.5, { xStart, xEnd });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawSimpleBinaryTree);\n//# sourceMappingURL=drawSimpleBinaryTree.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/drawSimpleBinaryTree.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/canvas/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/canvas/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasComponent\": () => (/* reexport safe */ _Canvas__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"drawBinaryTree\": () => (/* reexport safe */ _drawBinaryTree__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas */ \"./node_modules/binary-tree-visualizer/lib/canvas/Canvas.js\");\n/* harmony import */ var _drawBinaryTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawBinaryTree */ \"./node_modules/binary-tree-visualizer/lib/canvas/drawBinaryTree.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/canvas/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/config/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/config/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setTheme\": () => (/* reexport safe */ _theme__WEBPACK_IMPORTED_MODULE_0__.setTheme)\n/* harmony export */ });\n/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/config/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/config/theme.js":
/*!*****************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/config/theme.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setTheme\": () => (/* binding */ setTheme),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst theme = {\n    radius: 20,\n    growthAndShrinkTimes: 1.25,\n    leafNodeSpace: 75,\n    lineHeight: 90,\n    fontSize: 10,\n    textFont: 'Poppins',\n    strokeColor: '#f56042',\n    colorArray: [\n        { bgColor: '#fff2e0', borderColor: '#f56042' },\n    ],\n};\n/**\n * Set the user defined theme if required\n *\n * @param {Theme} userDefinedTheme\n */\nfunction setTheme(userDefinedTheme) {\n    const { radius = theme.radius, growthAndShrinkTimes = theme.growthAndShrinkTimes, leafNodeSpace = theme.leafNodeSpace, lineHeight = theme.lineHeight, colorArray = theme.colorArray, textFont = theme.textFont, strokeColor = theme.strokeColor, fontSize = theme.fontSize, } = userDefinedTheme;\n    theme.radius = radius;\n    theme.growthAndShrinkTimes = growthAndShrinkTimes;\n    theme.leafNodeSpace = leafNodeSpace;\n    theme.lineHeight = lineHeight;\n    theme.colorArray = colorArray;\n    theme.textFont = textFont;\n    theme.strokeColor = strokeColor;\n    theme.fontSize = fontSize;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (theme);\n//# sourceMappingURL=theme.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/config/theme.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VisualizationType\": () => (/* binding */ VisualizationType)\n/* harmony export */ });\nvar VisualizationType;\n(function (VisualizationType) {\n    VisualizationType[VisualizationType[\"SIMPLE\"] = 0] = \"SIMPLE\";\n    VisualizationType[VisualizationType[\"PRETTY\"] = 1] = \"PRETTY\";\n    VisualizationType[VisualizationType[\"EXPANDABLE\"] = 2] = \"EXPANDABLE\";\n    VisualizationType[VisualizationType[\"HIGHLIGHT\"] = 3] = \"HIGHLIGHT\";\n})(VisualizationType || (VisualizationType = {}));\n//# sourceMappingURL=VisualizationType.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/enumns/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/enumns/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VisualizationType\": () => (/* reexport safe */ _VisualizationType__WEBPACK_IMPORTED_MODULE_0__.VisualizationType)\n/* harmony export */ });\n/* harmony import */ var _VisualizationType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VisualizationType */ \"./node_modules/binary-tree-visualizer/lib/enumns/VisualizationType.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/enumns/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/helpers/ColorGenerator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/helpers/ColorGenerator.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_getRGBString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getRGBString */ \"./node_modules/binary-tree-visualizer/lib/utils/getRGBString.js\");\n\n/**\n * The gap between 2 ids\n */\nconst gap = 10;\n/**\n * For generating color\n */\nclass ColorGenerator {\n    constructor() {\n        /**\n         * The red color value\n         */\n        this.red = 0;\n        /**\n         * The green color value\n         */\n        this.green = 0;\n        /**\n         * The blue color value\n         */\n        this.blue = 1;\n    }\n    /**\n     * Increment a color\n     *\n     * @param {'red' | 'green' | 'blue'} color\n     */\n    incrementColor(color) {\n        this[color] = (this[color] + gap) % 256;\n    }\n    /**\n     * Get the next color\n     * Starts from rgb(0, 0, 0)\n     *\n     * @return {string}\n     */\n    getNextColor() {\n        // Generate the rgb value\n        const color = (0,_utils_getRGBString__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.red, this.green, this.blue);\n        // Increment the color\n        this.incrementColor('blue');\n        if (this.blue < gap) {\n            this.incrementColor('green');\n            if (this.green < gap) {\n                this.incrementColor('red');\n            }\n        }\n        // Return the color\n        return color;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorGenerator);\n//# sourceMappingURL=ColorGenerator.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/helpers/ColorGenerator.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BinarySearchTreeNode\": () => (/* reexport safe */ _tree__WEBPACK_IMPORTED_MODULE_0__.BinarySearchTreeNode),\n/* harmony export */   \"BinaryTreeNode\": () => (/* reexport safe */ _tree__WEBPACK_IMPORTED_MODULE_0__.BinaryTreeNode),\n/* harmony export */   \"CanvasComponent\": () => (/* reexport safe */ _canvas__WEBPACK_IMPORTED_MODULE_1__.CanvasComponent),\n/* harmony export */   \"drawBinaryTree\": () => (/* reexport safe */ _canvas__WEBPACK_IMPORTED_MODULE_1__.drawBinaryTree),\n/* harmony export */   \"VisualizationType\": () => (/* reexport safe */ _enumns__WEBPACK_IMPORTED_MODULE_2__.VisualizationType),\n/* harmony export */   \"setTheme\": () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_3__.setTheme)\n/* harmony export */ });\n/* harmony import */ var _tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree */ \"./node_modules/binary-tree-visualizer/lib/tree/index.js\");\n/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvas */ \"./node_modules/binary-tree-visualizer/lib/canvas/index.js\");\n/* harmony import */ var _enumns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enumns */ \"./node_modules/binary-tree-visualizer/lib/enumns/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"./node_modules/binary-tree-visualizer/lib/config/index.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/shapes/Circle.js":
/*!******************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/shapes/Circle.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n\n/**\n * Rate at which circle will grow or shrink\n */\nconst growthRate = 0.3;\n/**\n * Describes a circle in the canvas\n */\nclass Circle {\n    /**\n     * For constructing a new circle\n     *\n     * @param {string} value\n     * @param {number} radius\n     * @param {CircleColorSettings} colorSettings\n     */\n    constructor(value, radius, colorSettings) {\n        /**\n         * The colorId of the circle\n         */\n        this.colorId = '';\n        /**\n         * X Position of the circle\n         */\n        this.x = -1;\n        /**\n         * Y Position of the circle\n         */\n        this.y = -1;\n        this.value = value;\n        this.colorSettings = colorSettings;\n        this.radiusSettings = {\n            currentRadius: radius,\n            originalRadius: radius,\n            maxRadius: radius * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].growthAndShrinkTimes,\n            minRadius: radius / _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].growthAndShrinkTimes,\n        };\n    }\n    /**\n     * Draw the circle\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} radius\n     * @param {string} color\n     */\n    drawCircle(ctx, radius, color) {\n        const { x, y } = this;\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n        ctx.fill();\n    }\n    /**\n     * Draw the border\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    drawBorder(ctx) {\n        const { x, y, colorSettings, radiusSettings: { currentRadius: radius } } = this;\n        const { borderColor } = colorSettings;\n        ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n        ctx.strokeStyle = borderColor;\n        ctx.stroke();\n    }\n    /**\n     * Write the text\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    writeText(ctx) {\n        const { x, y, value, colorSettings } = this;\n        const { borderColor } = colorSettings;\n        // Decide font size\n        const fontSize = `${_config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fontSize}pt`;\n        const ySpacing = _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fontSize / 2;\n        ctx.fillStyle = borderColor;\n        ctx.font = `${fontSize} ${_config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].textFont}`;\n        ctx.textAlign = 'center';\n        ctx.fillText(value, x, y + ySpacing);\n    }\n    /**\n     * Get the current radius\n     *\n     * @return {number}\n     */\n    getRadius() {\n        const { radiusSettings: { currentRadius: radius }, } = this;\n        return radius;\n    }\n    /**\n     * Increase radius of the circle\n     * @param {number} maxRadius\n     * @return {boolean} - Weather size was changed\n     */\n    grow(maxRadius = this.radiusSettings.maxRadius) {\n        const { radiusSettings: { currentRadius, }, } = this;\n        if (currentRadius < maxRadius) {\n            const originalIncreasedRadius = currentRadius + growthRate;\n            this.radiusSettings.currentRadius = originalIncreasedRadius > maxRadius ?\n                maxRadius : originalIncreasedRadius;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Decrease the radius of the circle\n     * @param {number} minRadius\n     * @return {boolean} - Weather size was changed\n     */\n    shrink(minRadius = this.radiusSettings.minRadius) {\n        const { radiusSettings: { currentRadius, }, } = this;\n        if (currentRadius > minRadius) {\n            const originalDecreasedRadius = currentRadius - growthRate;\n            this.radiusSettings.currentRadius = originalDecreasedRadius < minRadius ?\n                minRadius : originalDecreasedRadius;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Bring the circle back to its original radius\n     * @return {boolean} - Weather size was changed\n     */\n    restoreCircle() {\n        const { radiusSettings: { currentRadius, originalRadius, }, } = this;\n        if (currentRadius > originalRadius) {\n            return this.shrink(originalRadius);\n        }\n        if (currentRadius < originalRadius) {\n            return this.grow(originalRadius);\n        }\n        return false;\n    }\n    /**\n     * Set the color id of the circle\n     *\n     * @param {string} colorId\n     */\n    setColorId(colorId) {\n        this.colorId = colorId;\n    }\n    /**\n     * Set the x and y coordinates of the circle\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n    setCoordinates(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Draw the circle on the screen\n     * Draw the border\n     * Add the text\n     *\n     * @param {CanvasComponent} comp\n     * @return {string} - The color id represented by the unique color\n     */\n    draw(comp) {\n        const { radiusSettings: { currentRadius: radius }, colorSettings: { bgColor }, } = this;\n        // Draw circle\n        this.colorId = this.colorId ? this.colorId : comp.getNextColor();\n        this.drawCircle(comp.getContext(), radius, bgColor);\n        this.drawCircle(comp.getHitContext(), radius, this.colorId);\n        // Draw border\n        this.drawBorder(comp.getContext());\n        // Write text\n        this.writeText(comp.getContext());\n        // Return the colorId\n        return this.colorId;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Circle);\n//# sourceMappingURL=Circle.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/shapes/Circle.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/strokes/BezierCurve.js":
/*!************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/strokes/BezierCurve.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Describes a bezier curve\n */\nclass BezierCurve {\n    /**\n     * Construct a new bezier curve\n     *\n     * @param {string} color\n     * @param {Point} start\n     * @param {Point} cp1\n     * @param {Point} cp2\n     * @param {Point} end\n     */\n    constructor(color, start, cp1, cp2, end) {\n        const { x: xStart, y: yStart } = start;\n        const { x: cp1x, y: cp1y } = cp1;\n        const { x: cp2x, y: cp2y } = cp2;\n        const { x: xEnd, y: yEnd } = end;\n        this.color = color;\n        this.xStart = xStart;\n        this.yStart = yStart;\n        this.cp1x = cp1x;\n        this.cp1y = cp1y;\n        this.cp2x = cp2x;\n        this.cp2y = cp2y;\n        this.xEnd = xEnd;\n        this.yEnd = yEnd;\n    }\n    /**\n     * Draw the bezier curve\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    draw(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.xStart, this.yStart);\n        ctx.strokeStyle = this.color;\n        ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.xEnd, this.yEnd);\n        ctx.stroke();\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BezierCurve);\n//# sourceMappingURL=BezierCurve.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/strokes/BezierCurve.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/tree/BinarySearchTreeNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/tree/BinarySearchTreeNode.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _BinaryTreeNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryTreeNode */ \"./node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js\");\n\n/**\n * A Binary search tree node\n */\nclass BinarySearchTreeNode extends _BinaryTreeNode__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * Set the left child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setLeft(value) {\n        super.setLeft(value);\n    }\n    /**\n     * Set the right child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setRight(value) {\n        super.setRight(value);\n    }\n    /**\n     * Insert a value into the node\n     * (Using Recursion)\n     *\n     * @param {T} value\n     */\n    insert(value) {\n        // Skip equal value\n        if (value === this.value) {\n            return;\n        }\n        // When value is lesser\n        if (value < this.value) {\n            if (this.left) {\n                this.left.insert(value);\n                return;\n            }\n            this.setLeft(new BinarySearchTreeNode(value));\n            return;\n        }\n        // When value is greater\n        if (this.right) {\n            this.right.insert(value);\n            return;\n        }\n        this.setRight(new BinarySearchTreeNode(value));\n    }\n    /**\n     * Find the minimum value from the given node\n     *\n     * @param {BinarySearchTreeNode<T>} node\n     * @return {BinarySearchTreeNode<T>}\n     */\n    findMinimum() {\n        if (this.left) {\n            return this.left.findMinimum();\n        }\n        return this;\n    }\n    /**\n     * Delete this node\n     *\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    deleteThisNode(parent) {\n        // Which direction is this node from the parent\n        const childDirection = (parent === null || parent === void 0 ? void 0 : parent.left) === this ? 'left' : 'right';\n        // Case 1: Delete leaf node\n        if (!this.left && !this.right) {\n            if (parent) {\n                delete parent[childDirection];\n            }\n            return [this];\n        }\n        // Case 2: Delete when there is only one child\n        if (this.left && !this.right) {\n            if (parent) {\n                parent[childDirection] = this.left;\n            }\n            return [this, this.left];\n        }\n        else if (this.right && !this.left) {\n            if (parent) {\n                parent[childDirection] = this.right;\n            }\n            return [this, this.right];\n        }\n        // Case 3: There are 2 children\n        // Step 1: Delete the in order successor\n        const [deletedNode] = this.right.delete(this.right.findMinimum().value, this);\n        // Step 2: Set the in order successor as the current node\n        // Deleted node will always be found\n        deletedNode.left = this.left;\n        deletedNode.right = this.right;\n        if (parent) {\n            parent[childDirection] = deletedNode;\n        }\n        return [this, deletedNode];\n    }\n    /**\n     * Delete a node\n     * (Using recursion)\n     *\n     * @param {T} value\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    delete(value, parent) {\n        // Delete from left node\n        if (value < this.value && this.left) {\n            const [deletedNode] = this.left.delete(value, this);\n            return [deletedNode, this];\n        }\n        // Delete from right node\n        if (value > this.value && this.right) {\n            const [deletedNode] = this.right.delete(value, this);\n            return [deletedNode, this];\n        }\n        // Delete the current node\n        if (this.value === value) {\n            const res = this.deleteThisNode(parent);\n            delete this.left;\n            delete this.right;\n            return res;\n        }\n        return [, this];\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BinarySearchTreeNode);\n//# sourceMappingURL=BinarySearchTreeNode.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/tree/BinarySearchTreeNode.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _shapes_Circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/Circle */ \"./node_modules/binary-tree-visualizer/lib/shapes/Circle.js\");\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n/* harmony import */ var _utils_getRandomColor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getRandomColor */ \"./node_modules/binary-tree-visualizer/lib/utils/getRandomColor.js\");\n\n\n\n/**\n * Describes a node of a binary tree\n */\nclass BinaryTreeNode {\n    /**\n     * For constructing a new binary tree node\n     *\n     * @param {T} value\n     */\n    constructor(value) {\n        this.value = value;\n        this.nodeCircle = new _shapes_Circle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`${value}`, _config_theme__WEBPACK_IMPORTED_MODULE_1__[\"default\"].radius, (0,_utils_getRandomColor__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n    }\n    /**\n     * Set the left child\n     *\n     * @param {BinaryTreeNode} value\n     */\n    setLeft(value) {\n        this.left = value;\n    }\n    /**\n     * Set the right child\n     *\n     * @param {BinaryTreeNode} value\n     */\n    setRight(value) {\n        this.right = value;\n    }\n    /**\n     * Get the height of the binry tree from the node\n     * Height of root is 1\n     *\n     * @return {number}\n     */\n    getHeight() {\n        var _a, _b;\n        const leftHeight = ((_a = this.left) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n        const rightHeight = ((_b = this.right) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BinaryTreeNode);\n//# sourceMappingURL=BinaryTreeNode.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/tree/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/tree/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BinaryTreeNode\": () => (/* reexport safe */ _BinaryTreeNode__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"BinarySearchTreeNode\": () => (/* reexport safe */ _BinarySearchTreeNode__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _BinaryTreeNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryTreeNode */ \"./node_modules/binary-tree-visualizer/lib/tree/BinaryTreeNode.js\");\n/* harmony import */ var _BinarySearchTreeNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BinarySearchTreeNode */ \"./node_modules/binary-tree-visualizer/lib/tree/BinarySearchTreeNode.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/tree/index.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n/* harmony import */ var _strokes_BezierCurve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../strokes/BezierCurve */ \"./node_modules/binary-tree-visualizer/lib/strokes/BezierCurve.js\");\n\n\n/**\n * Connect two points with a bezier curve\n *\n * @param {CanvasComponent} canvasComponent\n * @param {HorizontalStartAndEndInput} horizontalConfig\n * @param {VerticalStartAndEndInput} verticalConfig\n */\nfunction connectPointsWithBezierCurve(canvasComponent, horizontalConfig, verticalConfig) {\n    // X, Y Calculation\n    const { xStart, xEnd } = horizontalConfig;\n    const { yStart, yEnd } = verticalConfig;\n    const halfY = (yStart + yEnd) / 2;\n    const halfX = (xStart + xEnd) / 2;\n    // Draw the bezier curve\n    const berzierCurve = new _strokes_BezierCurve__WEBPACK_IMPORTED_MODULE_1__[\"default\"](_config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].strokeColor, { x: xStart, y: yStart }, { x: halfX, y: halfY }, { x: xEnd, y: halfY }, { x: xEnd, y: yEnd });\n    berzierCurve.draw(canvasComponent.getContext());\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectPointsWithBezierCurve);\n//# sourceMappingURL=connectPointsWithBezierCurve.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/utils/connectPointsWithBezierCurve.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/utils/getRGBString.js":
/*!***********************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/utils/getRGBString.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Get RGB string from red green and blue values\n *\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @return {string}\n */\nfunction getRGBString(red, green, blue) {\n    return `rgb(${red}, ${green}, ${blue})`;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRGBString);\n//# sourceMappingURL=getRGBString.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/utils/getRGBString.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/utils/getRandomColor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/utils/getRandomColor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n\n/**\n * Get a random color settings\n *\n * @return {CircleColorSettings}\n */\nfunction getRandomColor() {\n    const { colorArray } = _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    return colorArray[Math.floor(Math.random() * colorArray.length)];\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRandomColor);\n//# sourceMappingURL=getRandomColor.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/utils/getRandomColor.js?");

/***/ }),

/***/ "./node_modules/binary-tree-visualizer/lib/utils/tree.js":
/*!***************************************************************!*\
  !*** ./node_modules/binary-tree-visualizer/lib/utils/tree.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getMaxLeafNodesFromHeight\": () => (/* binding */ getMaxLeafNodesFromHeight),\n/* harmony export */   \"getCanvasWidthFromMaxNodeSpacing\": () => (/* binding */ getCanvasWidthFromMaxNodeSpacing),\n/* harmony export */   \"getXPositionFromGivenHorizontalNodePosition\": () => (/* binding */ getXPositionFromGivenHorizontalNodePosition),\n/* harmony export */   \"getCanvasHeightFromTreeHeight\": () => (/* binding */ getCanvasHeightFromTreeHeight),\n/* harmony export */   \"getRequiredAndActualHeightAndWidth\": () => (/* binding */ getRequiredAndActualHeightAndWidth)\n/* harmony export */ });\n/* harmony import */ var _config_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme */ \"./node_modules/binary-tree-visualizer/lib/config/theme.js\");\n\n/**\n * Get the max number of leaf nodes from height of the binary tree\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - Maximum number of leaf nodes\n */\nfunction getMaxLeafNodesFromHeight(treeHeight) {\n    return Math.pow(2, (treeHeight - 1));\n}\n/**\n * Maximum canvas width required from number of tree nodes\n *\n * @param {number} maxNodes - Maximum number of nodes\n * @return {number} - The max width required\n */\nfunction getCanvasWidthFromMaxNodeSpacing(maxNodes) {\n    return (maxNodes + 2) * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace;\n}\n/**\n * Get the x position from given horizontal node position\n *\n * @param {number} nodes - The number of nodes from the left\n * @return {number} - The x position\n */\nfunction getXPositionFromGivenHorizontalNodePosition(nodes) {\n    return (nodes) * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].leafNodeSpace;\n}\n/**\n * Get canvas height from the tree height\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - The canvas height in px\n */\nfunction getCanvasHeightFromTreeHeight(treeHeight) {\n    return (treeHeight) * _config_theme__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lineHeight;\n}\n/**\n * Get required and actual height and width\n *\n * @param {number} maxNodeSpacing\n * @param {number} heightOfTree\n * @param {number} maxWidth\n * @param {number} maxHeight\n * @return {{\n *  maxCanvasHeightRequired: number,\n *  maxCanvasWidthRequired:number,\n *  actualMaxHeight: number,\n *  actualMaxWidth: number\n * }}\n */\nfunction getRequiredAndActualHeightAndWidth(maxNodeSpacing, heightOfTree, maxWidth, maxHeight) {\n    const maxCanvasWidthRequired = getCanvasWidthFromMaxNodeSpacing(maxNodeSpacing);\n    const maxCanvasHeightRequired = getCanvasHeightFromTreeHeight(heightOfTree + 1);\n    const actualMaxWidth = maxCanvasWidthRequired > maxWidth ?\n        maxCanvasWidthRequired : maxWidth;\n    const actualMaxHeight = maxCanvasHeightRequired > maxHeight ?\n        maxCanvasHeightRequired : maxHeight;\n    return {\n        maxCanvasHeightRequired,\n        maxCanvasWidthRequired,\n        actualMaxHeight,\n        actualMaxWidth,\n    };\n}\n//# sourceMappingURL=tree.js.map\n\n//# sourceURL=webpack://example-binary-tree-visualizer/./node_modules/binary-tree-visualizer/lib/utils/tree.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;